# 面向对象进阶



## static



### static 是什么

* static是静态的意思，可以用来修饰成员变量、成员方法。
* static修饰成员变量之后称为静态成员变量（类变量），修饰方法之后称为静态方法（类方法）。
* static修饰后的成员变量，可以被类的所有对象共享（访问、修改)。



### 内存原理

* 加载时间
* 只有一份



###成员方法的分类

* 静态成员方法（有static修饰，归属于类），建议用类名访问，也可以用对象访问。
* 实例成员方法（无static修饰，归属于对象），只能用对象触发访问。



###static 访问注意事项

* 静态方法只能访问静态的成员，不可以直接访问实例成员。
* 实例方法可以访问静态的成员，也可以访问实例成员。
* 静态方法中是不可以出现this关键字的。 



### 工具类

* 类中都是一些静态方法，每个方法都是以完成一个共用的功能为目的，这个类用来给系统开发人员共同使用的。
* 一是调用方便，二是提高了代码复用（一次编写，处处可用）
* 由于工具里面都是静态方法，直接用类名即可访问，因此，工具类无需创建对象，建议将工具类的构造器进行私有。



### 代码块

> 代码块是类的5大成分之一（成员变量、构造器，方法，代码块，内部类），定义在类中方法外。在Java类下，使用 { } 括起来的代码被称为代码块 。

* 静态代码块
  * 格式：static{}
  * 特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次
  * 使用场景：在类加载的时候做一些静态数据初始化的操作，以便后续使用。
* 构造代码块（了解即可）
  * 格式：{}
  * 特点：每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行
  * 使用场景：初始化实例资源。



## 设计模式 单例



###设计模式简介

* 开发中经常遇到一些问题，一个问题通常有n种解法的，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。
* 设计模式有20多种，对应20多种软件开发中会遇到的问题。
* 学设计模式主要是学2点：
  * 第一：这种模式用来解决什么问题。
  * 第二：遇到这种问题了，该模式是怎么写的，他是如何解决这个问题的。



### 单例模式

> 可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间。



#### 饿汉单例模式

> 在用类获取对象的时候，对象已经提前为你创建好了。

* 定义一个类，把构造器私有。
* 定义一个静态变量存储一个对象。



####懒汉单例模式

> 在真正需要该对象的时候，才去创建一个对象(延迟加载对象)。

* 定义一个类，把构造器私有。
* 定义一个静态变量存储一个对象。
* 提供一个返回单例对象的方法



##继承



### 简述

* Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。
* 子类（派生类）、父类(基类 或超类)。
* 作用：当子类继承父类后，就可以直接使用父类公共的属性和方法了
* 提高代码复用性，减少代码冗余，增强类的功能扩展性。



### 设计范式

* 子类们相同特征（共性属性，共性方法）放在父类中定义
* 子类独有的的属性和行为应该定义在子类自己里面。



### 内存特点

子类对象的内存中包含父类部分



### 继承的特点

* 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。
* Java是单继承模式：一个类只能继承一个直接父类。
* Java不支持多继承、但是支持多层继承。
* Java中所有的类都是Object类的子类。
* 子类不可以继承父类的构造器
* 子类可以继承父类的私有成员，但不能访问
* 父类的静态成员对于子类的关系为共享，不是继承（有争议）



### 访问特点

在子类方法中访问成员（成员变量、成员方法）满足：就近原则

* 先子类局部范围找
* 然后子类成员范围找
* 然后父类成员范围找，如果父类范围还没有找到则报错。



### 方法重写

>  在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。



#### 注意事项与要求

* 重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致。
* 私有方法不能被重写。
* 子类重写父类方法时，访问权限必须大于或者等于父类 （暂时了解 ：缺省 < protected < public）
* 子类不能重写父类的静态方法，如果重写会报错的。



#### @Override重写注解

* @Override是放在重写后的方法上，作为重写是否正确的校验注解。
* 加上该注解后如果重写错误，编译阶段会出现错误提示。
* 建议重写方法都加@Override注解，代码安全，优雅！



### 子类构造器

* 默认先执行父类构造器
  * 未写 super( ... )，自动调用父类无参构造器
  * 否则，调用所写的构造器
  * 注：
    * 必须在第一行
    * this 与 super 只能存在一个，this 的调用中包含 super

* 理解：
  * 子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。
  * 子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。



## 包

* 包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。
* 建包的语法格式：package 公司域名倒写.技术名称。
* 包名建议全部英文小写，且具备意义建包语句必须在第一行，一般IDEA工具会帮助创建

> 导包：
>
> * 相同包下的类可以直接访问，不同包下的类必须导包,才可以使用！导包格式：import 包名.类名;
> * 假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问。



## 权限修饰符

* 权限修饰符：是用来控制一个成员能够被访问的范围。
* 可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。
* 权限修饰符：有四种作用范围由小到大（private -> 缺省 -> protected - > public ）

|  修饰符   | 同一个类中 | 同一个包中其他类 | 不同包下的子类 | 不同包下的无关类 |
| :-------: | :--------: | :--------------: | :------------: | :--------------: |
|  private  |     √      |                  |                |                  |
|   缺省    |     √      |        √         |                |                  |
| protected |     √      |        √         |       √        |                  |
|  public   |     √      |        √         |       √        |        √         |

* 自定义成员一般满足的要求
  * 成员变量一般私有。
  * 方法一般公开。
  * 如果该成员只希望本类访问，使用private修饰。
  * 如果该成员只希望本类，同一个包下的其他类和子类访问，使用protected修饰。



## final

* final 关键字是最终的意思，可以修饰（类、方法、变量）
* 修饰类：表明该类是最终类，不能被继承。
* 修饰方法：表明该方法是最终方法，不能被重写。
* 修饰变量：表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次)。

> 注意：
>
> * final修饰的变量是基本类型：那么变量存储的数据值不能发生改变。
> * final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的。



## 常量

* 常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。
* 常量名的命名规范：英文单词全部大写，多个单词下划线连接起来。

* 原理：在编译阶段会进行 “宏替换” ——把使用常量的地方全部替换成真实的字面量。
* 优势：维护系统容易，可读性更好。



## 枚举



###概述

* 枚举是Java中的一种特殊类型
* 枚举的作用："是为了做信息的标志和信息的分类"。



###格式

```java
修饰符 enum 枚举名称{
            第一行都是罗列枚举类实例的名称。
}
```



###特征

* 枚举类都是继承了枚举类型：java.lang.Enum
* 枚举都是最终类，不可以被继承。
* 构造器都是私有的，枚举对外不能创建对象。
* 枚举类的第一行默认都是罗列枚举对象的名称的。
* 枚举类相当于是多例模式。



##抽象类



###概述

* 在Java中abstract是抽象的意思，可以修饰类、成员方法。
* abstract修饰类，这个类就是抽象类；修饰方法，这个方法就是抽象方法。

```java
修饰符 abstract class 类名{ 
	修饰符 abstract 返回值类型 方法名称(形参列表)；
}
```

* 注意：
  * 抽象方法只有方法签名，不能声明方法体。
  * 一个类中如果定义了抽象方法，这个类必须声明成抽象类，否则报错。



###特征与注意事项

* 类有的成员（成员变量、方法、构造器）抽象类都具备
* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
* 一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。
* 不能用abstract修饰变量、代码块、构造器。
* 最重要的特征：得到了抽象方法，失去了创建对象的能力（有得有失）



### final 与 abstruct 的关系

* 互斥关系
* abstract定义的抽象类作为模板让子类继承，final定义的类不能被继承。
* 抽象方法定义通用功能让子类重写，final定义的方法子类不能重写。



### 模板方法

* 可变部分：abstract修饰
* 不可变部分：final修饰



##多态



### 概述

* 指对象可以有多种形态。
* 常见形式：
  * 父类类型 对象名称 = new 子类构造器;
* 访问特点
  * 方法调用：编译看左边，运行看右边。
  * 变量调用：编译看左边，运行也看左边。（注意）
* 前提
  * 有继承/实现关系；
  * 有父类引用指向子类对象；
  * 有方法重写（多态侧重行为多态）。



### 优势

* 在多态形式下，右边对象可以实现解耦合，便于扩展和维护

```java
Animal a = new Dog();
a.run(); // 后续业务行为随对象而变，后续代码无需修改
```

* 定义方法的时候，使用父类型作为参数，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利。
* 多态下会产生的一个问题:多态下不能使用子类的独有功能



### 类型转换

* 自动类型转换（从子到父)
* 强制类型转换（从父到子)
  * 从父到子（ 必须进行强制类型转换,否则报错）:  子类 对象变量 = (子类)父类类型的变量 
  * 作用：可以解决多态下的劣势，可以实现调用子类独有的功能。 
  * 注意：
    *  有继承/实现关系的类就可以在编译阶段进行强制类型转换；
    * 但是，如果转型后的类型和对象真实对象的类型不是同一种类型，那么在运行代码时，就会出现ClassCastException

> Java建议强转转换前使用instanceof判断当前对象的真实类型，再进行强制转换



## 接口



### 概述、特点

* 接口的格式如下：

```java
接口用关键字interface来定义
public interface 接口名 {
       // 常量
       // 抽象方法
} 
```

*  JDK8之前接口中只能是抽象方法和常量，没有其他成分了。
* 接口不能实例化。接口中的成员都是public修饰的，写不写都是，因为规范的目的是为了公开化。



### 接口实现

* 接口是用来被类实现（implements）的，实现接口的类称为实现类。实现类可以理解成所谓的子类。

```java
修饰符 class 实现类 implements 接口1, 接口2, 接口3 , ... {
}
实现的关键字：implements
```

*  从上面可以看出，接口可以被类单实现，也可以被类多实现。
* 注意：
  * 一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类。



### 接口继承

* 类和类的关系：单继承。
* 类和接口的关系：多实现。
* 接口和接口的关系：多继承，一个接口可以同时继承多个接口。

> 接口多继承的作用：
>
> * 规范合并，整合多个接口为同一个接口，便于子类实现。



###注意事项

* 接口不能创建对象
* 一个类实现多个接口，多个接口的规范不能冲突
* 一个类实现多个接口，多个接口中有同样的静态方法不冲突。
* 一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。
* 一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。
* 一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。



###JDK 8 以后新增方法



#### 默认方法

* 类似之前写的普通实例方法：必须用default修饰
* 默认会public修饰。需要用接口的实现类的对象来调用

```java
default void run(){
    System.out.println("--开始跑--");
}
```



#### 静态方法

* 默认会public修饰，必须static修饰。
* 注意：接口的静态方法必须用本身的接口名来调用。

```java
static void inAddr(){
    System.out.println("我们都在黑马培训中心快乐的学习Java!");
}
```



#### 私有方法

* 就是私有的实例方法:，必须使用private修饰，从JDK 1.9才开始有的。
* 只能在本类中被其他的默认方法或者私有方法访问。

```java
private void go(){
    System.out.println("--准备--");
}
```



#### 添加原因

* 接口功能升级受限于抽象方法



## 内部类



### 概述

* 内部类就是定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解成（宿主）。
* 基本作用
  * 内部类通常可以方便访问外部类的成员，包括私有的成员。
  * 内部类提供了更好的封装性，内部类本身就可以用private ，protectecd等修饰，封装性可以做更多控制。
* 分类
  * 静态内部类[了解]
  * 成员内部类（非静态内部类） [了解]
  * 局部内部类[了解]
  * 匿名内部类（重点）



### 静态内部类

* 有static修饰，属于外部类本身。
* 它的特点和使用与普通类是完全一样的，类有的成分它都有，只是位置在别人里面而已。

```java
创建对象格式：
    外部类名.内部类名 对象名 = new 外部类名.内部类构造器;
```

* 静态内部类可以直接访问外部类的静态成员，不能直接访问外部类的实例成员



###成员内部类

* 无static修饰，属于外部类的对象。
* JDK16之前，成员内部类中不能定义静态成员，JDK 16开始也可以定义静态成员了。

```java
创建对象格式：
    外部类名.内部类名 对象名 = new  外部类构造器.new 内部类构造器();
```

* 可以直接访问外部类的静态成员，实例方法中可以直接访问外部类的实例成员。



### 局部内部类（鸡肋语法，了解即可）

* 局部内部类放在方法、代码块、构造器等执行体中。
* 局部内部类的类文件名为： 外部类$N内部类.class。



### 匿名内部类

* 本质上是一个没有名字的局部内部类。
* 作用：方便创建子类对象，最终目的是为了简化代码编写。

```java
new 类|抽象类名|或者接口名() {
    重写方法;
};
```

```java
Employee a = new Employee() {
    public void work() {
        
    }
};
a. work();
```

* 特点总结
  * 匿名内部类是一个没有名字的内部类，同时也代表一个对象。
  * 匿名内部类的对象类型，相当于是当前new的那个类型的子类类型。
